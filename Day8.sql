-- ************************************************ 24-12-2024 ******************************************
-- ************************************************ JOINS ********************************************

USE COMPANY;
SHOW TABLES;

CREATE TABLE Employees (
    EmpId INT PRIMARY KEY,
    FullName VARCHAR(100),
    Age INT,
    Department VARCHAR(50),
    Email VARCHAR(100)
);

INSERT INTO Employees (EmpId, FullName, Age, Department, Email)
VALUES
(101, 'Alice Johnson', 30, 'Human Resources', 'alice.johnson@example.com'),
(102, 'Bob Smith', 45, 'Finance', 'bob.smith@example.com'),
(103, 'Charlie Brown', 38, 'Marketing', 'charlie.brown@example.com'),
(104, 'David Lee', 28, 'Engineering', 'david.lee@example.com'),
(105, 'Eve White', 40, 'Sales', 'eve.white@example.com');


SELECT * FROM EMPLOYEES;

CREATE TABLE Salary (
    SalaryID INT PRIMARY KEY,
    EmployeeID INT,
    TotalSalary DECIMAL(10, 2)
);

INSERT INTO Salary (SalaryID, EmployeeID, TotalSalary)
VALUES
(1, 100, 60000.00),
(2, 101, 82000.00),
(3, 111, 72000.00),
(4, 104, 93000.00),
(5, 105, 68000.00);

SELECT * FROM SALARY;


-- ************************************* INNER JOIN ********************************
-- THIS RETURNS RECORDS THAT HAVE MATCHING VALUES IN BOTH THE TABLES.

SELECT * FROM EMPLOYEES 		-- IT WILL GIVE DATA FROM BOTH THE TABLE FOR WHICH EMPLOYEE ID WILL MATCH
INNER JOIN SALARY ON EMPLOYEES.EmpId = SALARY.EmployeeID;

SELECT FULLNAME, TOTALSALARY FROM EMPLOYEES AS E		-- THIS WILL ALSO FULLNAME AND THEIR SALARY FROM BOTH TABLE. HERE 'AS' IS USING AS ALIAS. WE CAN GIVE ANY NAME
INNER JOIN SALARY AS S ON E.EMPID = S.EMPLOYEEID;		-- ALIAS WE USE WHEN TABLE NAME IS TOO LONG. SO FOR EASIER PURPOSE WE DEFINE ALIAS AND CAN USE EVERYWHERE


-- ************************************* LEFT JOIN ********************************
-- THIS RETURNS ALL RECORDS FROM 1ST TABLE AS WELL AS FROM 2ND TABLE ALSO FOR WHICH VALUE GETS MATCH.

SELECT * FROM EMPLOYEES 		-- IT WILL GIVE ALL DATA FROM 1ST TABLE AND MATCHING DATA FROM 2ND TABLE FOR WHICH EMPLOYEE ID WILL MATCH..
LEFT JOIN SALARY ON EMPLOYEES.EMPID = SALARY.EMPLOYEEID;	-- YOU CAN SEE FOR NON MATCHING ID, VALUE IS SHOWING AS NULL.


-- ************************************* RIGHT JOIN ********************************
-- THIS RETURNS ALL RECORDS FROM 2ND TABLE AS WELL AS FROM 1ST TABLE ALSO FOR WHICH VALUE GETS MATCH. IT WORKS LIKE OPPOSITE OF LEFT JOIN..

SELECT * FROM EMPLOYEES 		-- IT WILL GIVE ALL DATA FROM 2ND TABLE AND MATCHING DATA FROM 1ST TABLE FOR WHICH EMPLOYEE ID WILL MATCH..
RIGHT JOIN SALARY ON EMPLOYEES.EMPID = SALARY.EMPLOYEEID;	-- YOU CAN SEE ALL DATA FROM 2ND TABLE AND MATCHING ID DATA FROM 1ST TABLE.


-- ************************************* FULL JOIN ********************************
-- THIS RETURNS ALL RECORDS WHEN THERE IS ANY VALUE GETS MATCH IN EITHER LEFT OR RIGHT.
-- IN MYSQL WE USE UNION OF LEFT JOIN AND RIGHT JOIN TO PERFORM FULL JOIN. WE CANT WRITE AS FULL JOIN OR FULL OUTER JOIN.
 
SELECT * FROM EMPLOYEES 		-- IT WILL GIVE ALL DATA FROM 1ST TABLE AND MATCHING DATA FROM 2ND TABLE FOR WHICH EMPLOYEE ID WILL MATCH..
LEFT JOIN SALARY ON EMPLOYEES.EMPID = SALARY.EMPLOYEEID
UNION
SELECT * FROM EMPLOYEES 		-- IT WILL GIVE ALL DATA FROM 2ND TABLE AND MATCHING DATA FROM 1ST TABLE FOR WHICH EMPLOYEE ID WILL MATCH..
RIGHT JOIN SALARY ON EMPLOYEES.EMPID = SALARY.EMPLOYEEID;	-- YOU CAN SEE ALL DATA FROM 2ND TABLE AND MATCHING ID DATA FROM 1ST TABLE.


-- ************************************* LEFT EXCLUSIVE JOIN ********************************
-- THIS RETURNS RECORDS WHICH ARE PRESENT IN LEFT TABLE ONLY AND THAT IS NOT MATCHING WITH RIGHT TABLE..
 
SELECT * FROM EMPLOYEES 		-- IT WILL GIVE DATA ONLY WHICH ARE NOT MATCHING WITH RIGHT TABLE.
LEFT JOIN SALARY ON EMPLOYEES.EMPID = SALARY.EMPLOYEEID
WHERE SALARY.EMPLOYEEID IS NULL;


-- ************************************* RIGHT EXCLUSIVE JOIN ********************************
-- THIS RETURNS RECORDS WHICH ARE PRESENT IN RIGHT TABLE ONLY AND THAT IS NOT MATCHING WITH LEFT TABLE..

SELECT * FROM EMPLOYEES 		-- IT WILL GIVE ONLY DATA THAT IS NOT MATCHING WITH 1ST TABLE..
RIGHT JOIN SALARY ON EMPLOYEES.EMPID = SALARY.EMPLOYEEID
WHERE EMPLOYEES.EMPID IS NULL;


-- ************************************* FULL EXCLUSIVE JOIN ********************************
-- THIS RETURNS RECORDS WHICH ARE PRESENT IN LEFT TABLE AND RIGHT TABLE ONLY. MATCHING RECORD WILL NOT COME UNDER THIS..

SELECT * FROM EMPLOYEES 		-- IT WILL GIVE ONLY DATA FROM LEFT TABLE WHICH ARE NOT MATCHING WITH RIGHT TABLE.
LEFT JOIN SALARY ON EMPLOYEES.EMPID = SALARY.EMPLOYEEID
WHERE SALARY.EMPLOYEEID IS NULL
UNION
SELECT * FROM EMPLOYEES 		-- IT WILL GIVE ONLY DATA FROM RIGHT TABLE AND THAT IS NOT MATCHING WITH LEFT TABLE..
RIGHT JOIN SALARY ON EMPLOYEES.EMPID = SALARY.EMPLOYEEID
WHERE EMPLOYEES.EMPID IS NULL;



-- ************************************* SELF JOIN ********************************
-- IT IS A REGULAR JOIN BUT THE TABLE IS JOINED WITH ITSELF..
-- IN BELOW TABLE THERE ARE SOME WORKER WHO WORKS UNDER THEIR MANAGER AND WE HAVE TO FIND OUT WHAT ARE NAME OF THEIR MANAGERS.
-- IN THIS CASE WE WILL USE SELF JOIN TO JOIN THE SAME TABLE WITH ITSELF.

CREATE TABLE WORKER (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    manager_id INT
);

INSERT INTO WORKER (id, name, manager_id)
VALUES
    (101, 'adam', 103),
    (102, 'bob', 104),
    (103, 'casey', NULL),
    (104, 'donald', 103);
    
SELECT * FROM WORKER;

SELECT * 
FROM WORKER AS A		-- AS A IS ALIAS.
JOIN WORKER AS B		-- AS B IS ALIAS.
ON A.ID = B.MANAGER_ID;	-- THIS WILL SHOW MANAGER DETAILS OF WORKERS

SELECT A.NAME AS WORKER_MANAGER, B.NAME AS WORKER		-- TO SEE THEIR MANAGERS NAME WE USED HERE COL ALIAS AS WORKER_MANAGER AND WORKER..
FROM WORKER AS A
JOIN WORKER AS B
ON A.ID = B.MANAGER_ID;




-- **************************************** UNIONS ****************************************
-- It is used to combine the result set of two or more SELECT statements. It gives UNIQUE records.
-- Conditions to use it:-->
-- Every SELECT statement should have the same number of columns.
-- Columns must have similar data types.
-- Columns in every SELECT statement should be in the same order.

SELECT FULLNAME FROM EMPLOYEES
UNION								-- IT WILL ADD ALL DISTINCT NAME FROM BOTH THE TABLES.
SELECT NAME FROM WORKER;

SELECT FULLNAME FROM EMPLOYEES
UNION	ALL							-- UNION ALL -  WILL ADD ALL NAME FROM BOTH THE TABLES INCLUDING DUPLICATE NAMES.
SELECT NAME FROM WORKER;



-- ***************************************** SUB QUERIES ********************************************************
-- IT IS LIKE NESTED QUERY OR INNER QUERY WHICH IS WRITTEN UNDER ANOTHER SQL QUERY.

-- FOR EXP - FIND AVG SALARY OF ALL EMPLOYEE.
-- FIND THE ID OF EMPLOYEE WHOSE SALARY > AVGERAGE SALARY.
SELECT * FROM SALARY;
SELECT AVG(TOTALSALARY) FROM SALARY;

SELECT EMPLOYEEID, TOTALSALARY FROM SALARY 
WHERE TOTALSALARY > (
SELECT AVG(TOTALSALARY) FROM SALARY
);



-- ************************************************* MySQL VIEWS************************************************************
-- A view is a virtual table based on the result set of an SQL statement.
-- IF YOU WANT TO PERFORM SOME OPERATION ON A TABLE BUT YOU DONT WANT TO TOUCH ALL DATA SO USING VIEW YOU CAN PERFORM THIS ACTION
-- MEANS YOU CAN CREATE A VIRTUAL TABLE FOR PARTICULAR DETAILS LIKE BELOW AND PERFORM YOUR OPERATION AND UNDERSTAND THE THINGS..

-- Example:
CREATE VIEW VIRTUAL_TABLE AS
SELECT EMPID, FULLNAME, AGE FROM EMPLOYEES;

DROP VIEW VIRTUAL_TABLE;		-- FOR DELETE THE VIEW YOU CAN DROP LIKE THIS USING VIEW COMMAND

SELECT * FROM VIRTUAL_TABLE;		-- NOW I CAN PERFORM MULTIPLE ACTION ON THIS VIEW LIKE BELOW

SELECT * FROM VIRTUAL_TABLE WHERE AGE > 30;		-- ALL THIS ACTION WILL NOT IMPACT ON OUR DB. YOU CAN CHECK UNDER COMPANY DB THERE IS SEPERATELY VIEW IS CREATED
DELETE FROM VIRTUAL_TABLE WHERE EMPID = 103;	
					
